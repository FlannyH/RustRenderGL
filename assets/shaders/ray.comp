#version 460
layout(local_size_x = 1, local_size_y = 1) in;
layout(rgba16f, binding = 0) uniform image2D img_input;

struct AABB {
    float min_x;
    float min_y;
    float min_z;
    float max_x;
    float max_y;
    float max_z;
};

struct BvhNode {
    AABB bounds;
    int left_first;
    int count;
};

struct Vertex {
    vec3 position;
    vec3 normal;
    vec2 _padding;
    vec4 tangent;
    vec4 colour;
    vec2 uv0;
    vec2 uv1;
};

struct Triangle {
    Vertex v0;
    Vertex v1;
    Vertex v2;
};

struct HitInfo {
    float distance;
    vec2 uv;
};

struct Ray {
    vec3 position;
    vec3 direction;
    vec3 one_over_direction;
    float length;
};

layout(std430, binding = 0) buffer buf_nodes {
    BvhNode nodes[];
};

layout(std430, binding = 1) buffer buf_indices {
    uint indices[];
};

layout(std430, binding = 2) buffer buf_triangles {
    Triangle triangles[];
};

layout(std430, binding = 3) buffer buf_counts {
    uint n_nodes;
    uint n_triangles;
};

layout (location = 0) uniform mat3 camera_rot;
layout (location = 1) uniform vec3 camera_pos;
layout (location = 2) uniform float viewport_width;
layout (location = 3) uniform float viewport_height;
layout (location = 4) uniform float viewport_depth;

vec3 direction;
vec3 one_over_direction;
int node_check_stack[256];
int node_check_add_cursor = 0;
int node_check_pop_cursor = 0;
int node_check_stack_size = 0;

bool ray_intersect_aabb(AABB bounds) {
    float tx1 = (bounds.min_x - camera_pos.x) * one_over_direction.x;
    float tx2 = (bounds.max_x - camera_pos.x) * one_over_direction.x;

    float tmin = min(tx1, tx2);
    float tmax = max(tx1, tx2);

    float ty1 = (bounds.min_y - camera_pos.y) * one_over_direction.y;
    float ty2 = (bounds.max_y - camera_pos.y) * one_over_direction.y;

    tmin = max(tmin, min(ty1, ty2));
    tmax = min(tmax, max(ty1, ty2));

    float tz1 = (bounds.min_z - camera_pos.z) * one_over_direction.z;
    float tz2 = (bounds.max_z - camera_pos.z) * one_over_direction.z;

    tmin = max(tmin, min(tz1, tz2));
    tmax = min(tmax, max(tz1, tz2));

    return tmax >= tmin && tmax >= 0.0;
}

HitInfo ray_intersect_triangle(Triangle triangle) {
    HitInfo hit_info;
    hit_info.distance = -1.0;

    vec3 edge1 = triangle.v1.position - triangle.v0.position;
    vec3 edge2 = triangle.v2.position - triangle.v0.position;
    vec3 h = cross(direction, edge2);
    float det = dot(edge1, h);

    if (det <= 0.0) {
        return hit_info;
    }

    float inv_det = 1.0 / det;
    vec3 v0_ray = camera_pos - triangle.v0.position;
    float u = inv_det * dot(v0_ray, h);
    if (u < 0.0 || u > 1.0) {
        return hit_info;
    }

    vec3 q = cross(v0_ray, edge1);
    float v = inv_det * dot(direction, q);
    if (v < 0.0 || (u + v) > 1.0) {
        return hit_info;
    }

    float t = inv_det * dot(edge2, q);
    if (t > 0.0) {
        hit_info.distance = t;
        hit_info.uv = vec2(u, v);
    }
    return hit_info;
}

void add_node_to_stack(int node_index) {
    node_check_stack[node_check_add_cursor] = node_index;
    node_check_add_cursor = (node_check_add_cursor + 1) % 256;
    node_check_stack_size += 1;
}

HitInfo ray_intersect_bvh_node(int node_index) {
    HitInfo closest_hit;
    closest_hit.distance = 1e30;

    // If not at leaf node yet 
    if (nodes[node_index].count != -1) {
        // If the ray hits this AABB
        if (ray_intersect_aabb(nodes[node_index].bounds)) {
            closest_hit.distance = 0.1;
            return closest_hit;
            // Add the child nodes to the stack
            add_node_to_stack(nodes[node_index].left_first);
            add_node_to_stack(nodes[node_index].left_first + 1);
        }
    }

    // Otherwise, intersect all triangles in this node
    else {
        HitInfo curr_hit;
        int begin = nodes[node_index].left_first;
        int end = begin + nodes[node_index].count;

        for (int i = begin; i < end; ++i) {
            curr_hit = ray_intersect_triangle(triangles[indices[i]]);
            if (curr_hit.distance > 0.0 && curr_hit.distance < closest_hit.distance) {
                closest_hit = curr_hit;
            }
        }
    }
    return closest_hit;
}

HitInfo ray_intersect_bvh() {
    HitInfo final_hit;
    final_hit.distance = 1e30;
    add_node_to_stack(0);
    while (node_check_stack_size > 0) {
        HitInfo curr_hit = ray_intersect_bvh_node(node_check_stack[node_check_pop_cursor]);
        node_check_pop_cursor += 1;
        node_check_stack_size -= 1;
        if (curr_hit.distance < final_hit.distance) {
            final_hit = curr_hit;
        }
    }
    return final_hit;
}


void main() {
    // Get UV coordinates
	ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy);
    ivec2 size = imageSize(img_input);
    vec2 uv = (vec2(pixel_coords) / vec2(size)) * 2.0 - 1.0;

    // Calculate forward vector
    vec3 forward_vec = normalize(vec3(
        (viewport_width * uv.x), 
        (viewport_height * uv.y),
        viewport_depth
    ));

    // Rotate it
    direction = forward_vec * camera_rot;
    one_over_direction = vec3(1.0, 1.0, 1.0) / direction;

    HitInfo final_hit;
    HitInfo curr_hit;
    final_hit = ray_intersect_bvh();

	vec4 pixel = vec4(direction, 1.0);
    if (final_hit.distance < 100000.0) {
        pixel.x = final_hit.distance;
        pixel.y = final_hit.distance;
        pixel.z = final_hit.distance;
    }
    
	imageStore(img_input, ivec2(pixel_coords.x, pixel_coords.y), pixel);
}